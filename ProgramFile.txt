    Java in 21 day.

    Actually, given that during this animation there will be a lot of sleeping of various intervals, it
makes sense to create a method that does the sleeping for the appropriate time interval. Call it
pauseheres its definition:

        void pause(int time) {
        try { Thread.sleep(time); }
        catch (InterruptedException e) { }
        }
    Back to the nekorun method. To summarize, nekorun iterates from the start position to the end
position. For each turn of the loop, it sets the current x position, sets currentimg to the right
animation frame, calls repaint, and pauses. Got it? Heres the definition of nekorun:

        void nekorun(int start, int end) {
        for (int i = start; i  end; i=10) {
        this.xpos = i;
         swap images
        if (currentimg == nekopics0)
        currentimg = nekopics1;
        else if (currentimg == nekopics1)
        currentimg = nekopics0;
        repaint();
        pause(150);
        }
        }

    Note that in that second line you increment the loop by ten pixels. Why ten pixels, and not, say,
five or eight? The answer is determined mostly through trial and error to see what looks right.
Ten seems to work best for the animation. When you write your own animations, you have to
play with both the distances and the sleep times until you get an animation you like.
    Speaking of repaint, lets cover the paint() method, which paints each frame. Here the paint
method is trivially simple; all paint is responsible for is painting the current image at the current
x and y positions. All that information is stored in global variables, so the paint method has only
a single line in it:

        public void paint(Graphics g) {
        g.drawImage(currentimg, xpos, ypos, this);
        }
    Now lets back up to the run() method, where the main processing of this animation is
happening.